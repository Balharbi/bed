{
    "collab_server" : "",
    "contents" : "#' Fit a Bayesian epiallele model\n#'\n#' Fits an epiallele model to DNAm sequencing data.\n#' @param Y is an N by d numeric matrix of 0's and 1's where each row is a\n#' sequencing read and each column corresponds to a CpG site. Missing data can\n#' be represented as NA.\n#' @usage fit = bed_fit(Y)\n#' @return A list structure where rho is the optimal number of epialleles\n#' and AIC is an N-dimensional vector where element q contains the Akaike\n#' information criterion score for a model with q epialleles. The model\n#' field contains fitted models for different values of q. Each model has a\n#' vector W which indicates which epiallele each observed read corresponds to,\n#' a matrix X where each row is an inferred epiallale, matches and\n#' mismatches are simply the total number of mis/matches, and beta is\n#' the inferred noise hyperparameter.\n#'\n#' @examples\n#' set.seed(1314)\n#'\n#' # Generate 50 reads that are fully methylated\n#' Y1 <- matrix(rep(c(1,1,1,1,1,1,1,1),50), nrow=50, ncol=8)\n#'\n#' # Generate 30 reads that are half methylated\n#' Y2 <- matrix(rep(c(1,1,1,1,0,0,0,0),30),nrow=30, ncol=8, byrow=TRUE)\n#'\n#' # Generate 20 reads that are fully unmethylated\n#' Y3 <- matrix(rep(c(0,0,0,0,0,0,0,0),20),nrow=20,ncol=8)\n#'\n#' # Combine them\n#' Y <- rbind(Y1,Y2,Y3)\n#'\n#' # Add some noise by randomly regenerating 20 percent of values\n#' Y[sample(1:800,80,replace=FALSE)] <- round(runif(80))\n#'\n#' # Make a few data missing\n#' Y[sample(1:800,5,replace=FALSE)] <- NA\n#'\n#' # Infer which epialleles are present\n#' fit <- bed_fit(Y)\n#'\n#' # Plot AIC score\n#' plot(fit$AIC[1:10], type='b', xlab='Q = number of epialleles',\n#'     ylab='AIC score')\n#'\n#' # The fit$rho field contains the optimal number of epialleles\n#' cat(' Optimal number of epialleles =', fit$rho,'\\n')\n#'\n#' #Marginalise over W posterior\n#' w.margin <- bed_marginal(Y, fit$model[[fit$rho]]$X, fit$model[[fit$rho]]$W)\n#'\n#' # Summing over the columns gives the total proportion of reads that are\n#' # attributed to each epiallele\n#' p <- apply(w.margin, 2, FUN='sum')/100\n#' cat(' Inferred Epiallele [1] =',paste(fit$model[[3]]$X[1,],collapse=\"\"),\n#'     ', Proportion =', p[1],'\\n',\n#'     'Inferred Epiallele [2] =',paste(fit$model[[3]]$X[2,],collapse=\"\"),\n#'     ', Proportion =', p[2],'\\n',\n#'     'Inferred Epiallele [3] =',paste(fit$model[[3]]$X[3,],collapse=\"\")\n#'     ,', Proportion =', p[3])\n#'\n#' @seealso \\code{\\link{bed_marginal}}\n\nbed_fit <- function(Y){\n\n   # Total number of reads\n   N <- nrow(Y)\n   # Preallocate a list for the output\n   results <- list(model=vector('list',N), AIC=rep(NA,N))\n\n   H <- hamming(Y)\n   fit <- hclust(as.dist(H), method = 'ward.D')\n\n   # ---------- Begin loop over N -------- #\n   for (q in 1:N){\n\n      # BREAK if there's only one barcode pair observed\n      if (N==1){\n         results$rho <- 1\n         break\n      }\n\n      # Fit model using LL function\n      results$model[[q]] <- MAPxw(Y, q, fit)\n      results$AIC[q] <- results$model[[q]]$AIC\n      results$rho <- which.min(results$AIC) # Current best estimate for corrected read count\n\n      # BREAK if there are no mismatches and q=1. This means the model has achieved a\n      # perfect fit so we can stop.\n      # BREAK if there are no mismatches.\n      if (results$model[[q]]$mismatches==0){\n         results$rho <- which.min(results$AIC[1:q])\n         break\n      }\n\n      # Search at least until q=10, then check to see if we've hit the minimum AIC score.\n      # The AIC is non monotonic so don't search in the last five values of q.\n      if ((q>=10) & (which.min(results$AIC[1:q])<(q-5))) break\n   }\n   # ---------- End loop over N -------- #\n\n   return(results)\n}\n",
    "created" : 1485958174048.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2613192325",
    "id" : "39245953",
    "lastKnownWriteTime" : 1486027258,
    "last_content_update" : 1486027258319,
    "path" : "~/Dropbox/bed/R/bed_fit.R",
    "project_path" : "R/bed_fit.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}